import { documentRepository } from '@/repositories/documentRepository';
import { documentTransformer } from '@/transformers/documentTransformer';
import { ApiResponse } from '@/types';
import { asyncHandler } from '@/utils/asyncHandler';
import { jsonResponse, notFoundResponse } from '@/utils/jsonResponse';
import { logger } from '@/utils/logger';

import { mediaRepository } from '@/repositories/mediaRepository';
import { claudeService } from '@/services/claudeAiService';
import { minioService } from '@/services/minioService';
import { PromptService } from '@/services/promptService';
import { DocumentDto, documentSchema, FilterDocumentDto, filterDocumentSchema, IdParams, idParamsSchema } from '@shared/dto';
import { DocumentCategory, DocumentStatus } from '@shared/enums/documentEnums';

class DocumentController {
    private logger = logger.child({
        module: '[App][DocumentController]',
    });

    public getAll = asyncHandler<unknown, FilterDocumentDto, unknown, DocumentDto[]>({
        querySchema: filterDocumentSchema,
        logger: this.logger,
        handler: async (request, reply): Promise<ApiResponse<DocumentDto[] | void> | void> => {
            const { page = 1, limit = 10, search, category, status, userId } = request.query;
            const skip = (Number(page) - 1) * Number(limit);

            const filters = { search, category, status, userId };
            const result = await documentRepository.findAll(filters, skip, Number(limit));
            const documents = result.data.map((document) => documentTransformer.toDocumentDto(document));

            return jsonResponse(reply, 'Documents r√©cup√©r√©s avec succ√®s', documents, 200, result.pagination);
        },
    });

    public getById = asyncHandler<unknown, unknown, IdParams, DocumentDto>({
        paramsSchema: idParamsSchema,
        logger: this.logger,
        handler: async (request, reply): Promise<ApiResponse<DocumentDto | void> | void> => {
            const { id } = request.params;
            const document = await documentRepository.findById(id);

            if (!document) {
                return notFoundResponse(reply, 'Document non trouv√©');
            }

            const documentDto = documentTransformer.toDocumentDto(document);
            return jsonResponse(reply, 'Document r√©cup√©r√© avec succ√®s', documentDto, 200);
        },
    });

    // ==========================================
    // M√âTHODE COMPL√àTE D'UPLOAD ET CR√âATION
    // ==========================================
    public create = asyncHandler<unknown, unknown, unknown, DocumentDto>({
        logger: this.logger,
        handler: async (request: any, reply: any): Promise<ApiResponse<DocumentDto | void> | void> => {
            console.log('request.body :', request.body);
            // ==========================================
            // √âTAPE 1: R√âCUP√âRATION DU FICHIER MULTIPART
            // ==========================================
            const fileData = request.body?.file;
            if (!fileData) {
                return reply.code(400).send({
                    success: false,
                    message: 'Aucun fichier fourni'
                });
            }

            // ==========================================
            // √âTAPE 2: VALIDATION DU TYPE DE FICHIER
            // ==========================================
            const allowedMimeTypes = [
                'application/pdf', 
                'text/plain', 
                'application/msword', 
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            ];
            
            if (!allowedMimeTypes.includes(fileData.mimetype)) {
                return reply.code(400).send({
                    success: false,
                    message: 'Type de fichier non support√©. Formats accept√©s: PDF, TXT, DOC, DOCX'
                });
            }

            this.logger.info('üìÑ Fichier re√ßu pour upload', { 
                filename: fileData.filename, 
                mimetype: fileData.mimetype,
                size: fileData._buf?.length || 0 
            });

            // ==========================================
            // √âTAPE 3: UPLOAD VERS MINIO
            // ==========================================
            const uploadedFileName = await minioService.uploadFile(fileData);
            this.logger.info('‚òÅÔ∏è Fichier upload√© sur MinIO', { 
                originalName: fileData.filename, 
                storedName: uploadedFileName 
            });

            // ==========================================
            // √âTAPE 4: OBTENIR L'URL DU FICHIER
            // ==========================================
            const fileUrl = await minioService.getFile(uploadedFileName);

            // ==========================================
            const prompt = PromptService.generateCompleteAnalysisPrompt(fileData.filename || '');

            const media = await mediaRepository.create({
                url: fileUrl,
                filename: uploadedFileName,
                originalName: fileData.filename || '',
                mimeType: fileData.mimetype,
                size: fileData._buf?.length || 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            });

            // ==========================================
            // √âTAPE 6: CR√âER LE DOCUMENT EN BASE
            // ==========================================
            const document = await documentRepository.create({
                filename: uploadedFileName,
                originalName: fileData.filename || '',
                category: DocumentCategory.REPORT,
                status: DocumentStatus.PENDING,
                user: {
                    connect: {
                        id: request.user?.id || 'system'
                    }
                },
                media: {
                    connect: {
                        id: media.id
                    }
                }
            });

            this.logger.info('‚úÖ Document cr√©√© en base', { 
                documentId: document.id,
                status: document.status 
            });

            // ==========================================
            // √âTAPE 7: ANALYSE AVEC CLAUDE
            // ==========================================
            const pdfBuffer = await minioService.downloadFile(fileUrl);
            const pdfBase64 = pdfBuffer.toString('base64');

            const analysisResponse = await claudeService.analyzeDocument(prompt, pdfBase64);

            const analysis = JSON.parse(analysisResponse);

            // ==========================================
            // √âTAPE 8: MISE √Ä JOUR FINALE DU DOCUMENT
            // ==========================================
            const finalDocument = await documentRepository.update(document.id, {
                status: DocumentStatus.COMPLETED,
                summary: analysis.summary,
                keyPoints: {
                    create: analysis.keyPoints.map((keyPoint: any) => ({
                        title: keyPoint.title,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    }))
                },
                actionSuggestions: {
                    create: analysis.actionSuggestions.map((actionSuggestion: any) => ({
                        title: actionSuggestion.title,
                        label: actionSuggestion.label,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    }))
                },
                category: analysis.category || DocumentCategory.REPORT,
                totalPages: analysis.totalPages || undefined,
                processingTime: Date.now()
            });

            this.logger.info('üéâ Document trait√© avec succ√®s', { 
                documentId: finalDocument.id,
                finalStatus: finalDocument.status 
            });

            // ==========================================
            // √âTAPE 12: TRANSFORMATION ET R√âPONSE
            // ==========================================
            
            const documentDto = documentTransformer.toDocumentDto(finalDocument);
            return jsonResponse(reply, 'Document upload√© et analys√© avec succ√®s', documentDto, 201);
        },
    });

    // ==========================================
    // M√âTHODES UTILITAIRES
    // ==========================================
    
 

    public update = asyncHandler<Partial<DocumentDto>, unknown, IdParams, DocumentDto>({
        bodySchema: documentSchema.partial(),
        paramsSchema: idParamsSchema,
        logger: this.logger,
        handler: async (request: any, reply: any): Promise<ApiResponse<DocumentDto | void> | void> => {
            const { id } = request.params;
            const updateData = request.body;

            const documentExists = await documentRepository.findById(id);
            if (!documentExists) {
                return notFoundResponse(reply, 'Document non trouv√©');
            }

            const document = await documentRepository.update(id, updateData);
            const documentDto = documentTransformer.toDocumentDto(document);

            return jsonResponse(reply, 'Document mis √† jour avec succ√®s', documentDto, 200);
        },
    });

    public delete = asyncHandler<unknown, unknown, IdParams>({
        paramsSchema: idParamsSchema,
        logger: this.logger,
        handler: async (request: any, reply: any): Promise<ApiResponse<void> | void> => {
            const { id } = request.params;
            const documentExists = await documentRepository.findById(id);

            if (!documentExists) {
                return notFoundResponse(reply, 'Document non trouv√©');
            }

            await documentRepository.delete(id);
            return jsonResponse(reply, 'Document supprim√© avec succ√®s', undefined, 204);
        },
    });
}

export const documentController = new DocumentController();
